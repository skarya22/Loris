<?php declare(strict_types=1);
/**
 * The module to display study statistics
 *
 * PHP Version 7
 *
 * @category Loris
 * @package  Main
 * @author   Dave MacFarlane <driusan@bic.mni.mcgill.ca>
 * @license  http://www.gnu.org/licenses/gpl-3.0.txt GPLv3
 * @link     https://github.com/aces/Loris
 */
namespace LORIS\statistics;
use \Psr\Http\Message\ServerRequestInterface;
use \Psr\Http\Message\ResponseInterface;
use \Psr\Http\Server\RequestHandlerInterface;


/**
 * The module to display study statistics
 *
 * PHP Version 7
 *
 * @category Loris
 * @package  Main
 * @author   Dave MacFarlane <driusan@bic.mni.mcgill.ca>
 * @license  http://www.gnu.org/licenses/gpl-3.0.txt GPLv3
 * @link     https://github.com/aces/Loris
 */
class Charts extends \NDB_Page
{
    public $skipTemplate = true;
    /**
     * Checking user's permission
     *
     * @param \User $user The user whose access is being checked
     *
     * @return bool
     */
    function _hasAccess(\User $user) : bool
    {
        return $user->hasPermission('data_entry');
    }

    /**
     * Overrides the parent process function to re-add the application/json header
     * which otherwise sometimes gets removed if the middleware shortcircuits out
     * before calling handle.
     *
     * @param ServerRequestInterface  $request The PSR7 request
     * @param RequestHandlerInterface $handler The handler function
     *
     * @return ResponseInterface the PSR15 response that was generated by the
     * middleware
     */
    public function process(
        ServerRequestInterface $request,
        RequestHandlerInterface $handler
    ) : ResponseInterface {
        return parent::process($request, $handler)->withHeader(
            'Content-Type',
            'application/json'
        );
    }

    /**
     * Handle the incoming request.
     *
     * @param ServerRequestInterface $request The incoming PSR7 request
     *
     * @return ResponseInterface
     */
    public function handle(ServerRequestInterface $request) : ResponseInterface
    {
        if ($request->getMethod() !== 'GET') {
            return new \LORIS\Http\Response\JSON\MethodNotAllowed(['GET']);
        }

        // Strip any prefix of '/' to ensure that we don't have an empty string
        // when splitting the path, then there should be exactly 2 parts left,
        // "charts", and the endpoint requested.
        $url       = ltrim($request->getURI()->getPath(), '/');
        $pathparts = explode('/', $url);
        if (count($pathparts) != 2) {
            return new \LORIS\Http\Response\JSON\NotFound();
        }
        
        switch ($pathparts[1]) {
        case 'getDashboardChartInfo':
            return $this->_getDashboardChartInfo();
        case 'scans_bymonth':
            return $this->_handleScansByMonth();
        case 'siterecruitment_line':
            return $this->_handleSiteLineData();
        default:
            return $this->_handleBasicChartData($pathparts[1]);
        }
    }

    private function _getDashboardChartInfo() {
        // dashboard chart info
        $dashboardPanels = $this->loris->getConfiguration()->getSetting('dashboardCharts');
        $chartsData = [];
        foreach($dashboardPanels as $panel) {
            $decoded = json_decode($panel);
            
            if (!array_key_exists($decoded->panel, $chartsData)) {
                $chartsData[$decoded->panel] = [];
            }
            $decoded->filters = '';

            $decoded->chartType = key($decoded->options);
            $chartsData[$decoded->panel][$decoded->chartID] = $decoded;
        }

        // dashboard editor settings
        $DB = \NDB_Factory::singleton()->database();
        $chartOptions = [
            'tables' => [
                'candidate' => [
                    // available columns inside
                ]
            ],
            ''
        ];

        foreach($chartOptions['tables'] as $table) {
            $query = 'SHOW COLUMNS FROM ' . $table;

            $chartOptions['tables'][$table] = $DB->pselect($query, []);
        }

        $returnData = [
            'chartsData' => $chartsData,
            'chartOptions' => $chartOptions
        ];
        
        return new \LORIS\Http\Response\JsonResponse($returnData);
    }

    private function _handleBasicChartData($chartID)
    {
        // For Dashboard Charts:
        // extraWhere: extra where clause to be added to the query.
        //  ex.   'AND t.RegistrationCenterID IN (siteIDs)'
        //  ex.   'AND t.Sex = "Male"'
        // dataType = 'site' if extraWhere should replace 'siteIDs' with the allowed IDs of the user. 
        // dataType = 'ageSplit' if the chart is an age split chart. This will split the age into groups of 10 years.
        // dataLabels: the labels for the data. This is an array of strings.
        //  ex.   ["Male", "Female"] if groupedBy = 't.Sex'
        //  ex.   ["Participants"] if idColumn is based on the count of candidates.

        $dashboardCharts = $this->loris->getConfiguration()->getSetting('dashboardCharts');
        error_log("target chart is " . $chartID);
        $targetChartData;

        foreach($dashboardCharts as $chart) {
            $decoded = json_decode($chart);
            if ($decoded->chartID === $chartID) {
                $targetChartData = $decoded;
                break;
            }
        }

        if ($targetChartData === null) {
            return new \LORIS\Http\Response\JSON\NotFound();
        }

        $params = $this->_parseGetParameters();
        $user = \NDB_Factory::singleton()->user();
        $DB = \NDB_Factory::singleton()->database();
    
        $conditions = $this->_buildQueryConditions($params);
    
        $list_of_sites = $user->getStudySites();
    
        $siteIDs = implode(',', array_keys($list_of_sites));
    
        if ($targetChartData->dataType === 'site') {
            $targetChartData->extraWhere = str_replace('siteIDs', $siteIDs, $targetChartData->extraWhere);
        }
    
        $pieData = [
            ['x']
        ];

        $dataLabelIndex = [];
        $i = 1;
        foreach ($targetChartData->dataLabels as $dataLabel) {
            $pieData[] = [$dataLabel];
            $dataLabelIndex[$dataLabel] = $i;
            $i++;
        }

        if ($targetChartData->groupedBy === '') {
            $targetChartData->groupedBy = $targetChartData->idColumn;
        }
    
        $query = "SELECT {$targetChartData->groupedBy} as groupedBy, {$targetChartData->idColumn} as id, COUNT(t.CandID) AS totalRecruitment
                    FROM {$targetChartData->targetTable} t
                    {$conditions['cohortJoin']}
                    {$conditions['participantStatusJoin']}
                    WHERE t.Active='Y'
                    {$targetChartData->extraWhere}
                    AND t.Entity_type='Human'
                    {$conditions['projectQuery']}
                    {$conditions['cohortQuery']}
                    {$conditions['visitQuery']}
                    {$conditions['siteQuery']}
                    {$conditions['participantStatusQuery']}
                    GROUP BY {$targetChartData->groupedBy}, {$targetChartData->idColumn}";
    
        $results = $DB->pselect($query, []);
    
        foreach ($results as $_ => $value) {
            $name = $value['id'];
            $totalRecruitment = $value['totalRecruitment'];
    
            if ($targetChartData->dataType === 'site') {
                $name = $list_of_sites[$name];
            }
    
            if ($targetChartData->dataType === 'ageSplit') {
                $pieces = explode(' ', $targetChartData->idColumn);
                $last_word = array_pop($pieces) - 1;
    
                $startOfSplit = $name;
                $endOfSplit = $startOfSplit + $last_word;
                $name = $startOfSplit . '-' . $endOfSplit;
            }
    
            if (is_null($name)) {
                $name = "Unknown";
            }

            if (count($targetChartData->dataLabels) == 1) {
                $pieData[0][] = $name;
                $pieData[1][] = $totalRecruitment;
            } else {
                $pieData[0][] = $name;
                
                $pieData[$dataLabelIndex[$value['groupedBy']]][] = $totalRecruitment;
            }
        }

        error_log("pieData is " . json_encode($pieData));
    
        return new \LORIS\Http\Response\JsonResponse($pieData);
    }

    /**
     * Handle an incoming request for monthly progression
     *
     * @return ResponseInterface
     */
    private function _handleScansByMonth()
    {
        $params        = $this->_parseGetParameters();
        $user          = \NDB_Factory::singleton()->user();
        $list_of_sites = $user->getStudySites();

        $conditions = $this->_buildQueryConditions($params, true);

        $DB       = \NDB_Factory::singleton()->database();
        $scanData = [];
        // Run a query to get all the data. Order matters to ensure that the
        // labels are calculated in the correct order.
        $data = $DB->pselect(
            "SELECT s.CenterID,
                CONCAT(MONTH(pf.Value), '-', YEAR(pf.Value)) as datelabel,
                COUNT(distinct s.ID) as count
            FROM files f
            LEFT JOIN parameter_file pf USING (FileID)
            LEFT JOIN session s ON (s.ID=f.SessionID)
            {$conditions['participantStatusJoin']}
            JOIN parameter_type pt USING (ParameterTypeID)
            WHERE pt.Name='acquisition_date'
            {$conditions['projectQuery']}
            {$conditions['cohortQuery']}
            {$conditions['visitQuery']}
            {$conditions['siteQuery']}
            {$conditions['participantStatusQuery']}
            GROUP BY MONTH(pf.Value), YEAR(pf.Value), s.CenterID, datelabel
            ORDER BY YEAR(pf.Value), MONTH(pf.Value), s.CenterID",
            []
        );

        // TODO: make this work as bar data
        // Create the labels.
        //
        // We want to ensure that every month label appear exactly once and
        // in order, but the same label may appear multiple times across different
        // sites. Since the query was ordered, we use a new associative array
        // of labels and set the keys to to an arbitrary value (true) in order to
        // strip out duplicates, then take the keys of the resulting array once
        // done. The result should be an ordered numeric array with each label
        // for the chart in it exactly once.
        $labels = [];
        foreach ($data as $row) {
            $labels[$row['datelabel']] = true;
        }
        $scanData['labels'] = array_keys($labels);

        // Massage the data into the appropriate format per site.
        foreach ($list_of_sites as $siteID => $siteName) {
            $scanData['datasets'][] = [
                "name" => $siteName,
                "data" => $this->_getScansPerMonthData(
                    $data,
                    $siteID,
                    $scanData['labels']
                )
            ];
        }
        return (new \LORIS\Http\Response\JsonResponse($scanData));
    }

    /**
     * Helper to get the scans per month data in the correct format for a
     * given site
     *
     * @param array $data   The data for all sites.
     * @param int   $siteID The site to get the monthly data for.
     * @param array $labels An array of all valid labels. (Note that not
     *                      all labels may have data in $data, in which
     *                      case this function must include a "0" to maintain
     *                      order.)
     *
     * @return array An indexed array of data for site in the order of $labels
     */
    private function _getScansPerMonthData(
        array $data,
        int $siteID,
        array $labels
    ) : array {
        $sitedata   = array_filter(
            $data,
            function ($row) use ($siteID) {
                return $row['CenterID'] == $siteID;
            }
        );
        $mappeddata = [];
        foreach ($sitedata as $row) {
            $mappeddata[$row['datelabel']] = $row['count'];
        }

        $data = [];
        foreach ($labels as $i => $label) {
            $data[$i] = $mappeddata[$label] ?? 0;
        }
        return $data;
    }

    /**
     * Helper to handle the siterecruitment_line endpoint.
     *
     * @return ResponseInterface
     */
    private function _handleSiteLineData()
    {
        $params        = $this->_parseGetParameters();
        $user          = \NDB_Factory::singleton()->user();
        $list_of_sites = $user->getStudySites();

        $conditions = $this->_buildQueryConditions($params);

        $DB = \NDB_Factory::singleton()->database();

        $recruitmentData  = [];
        $recruitmentBound = $DB->pselect(
            "SELECT MIN(t.Date_registered), MAX(t.Date_registered)
            FROM candidate t
            {$conditions['cohortJoin']}
            WHERE t.Entity_type='Human'
            {$conditions['projectQuery']}
            {$conditions['cohortQuery']}
            {$conditions['siteQuery']}
            {$conditions['visitQuery']}",
            []
        );

        $recruitmentStartDate = $recruitmentBound[0]['MIN(t.Date_registered)'];
        $recruitmentEndDate   = $recruitmentBound[0]['MAX(t.Date_registered)'];

        if ($recruitmentStartDate !== null
            && $recruitmentEndDate !== null
        ) {
            $recruitmentData['labels'] = $this->_createSiteLineChartLabels(
                new \DateTimeImmutable($recruitmentStartDate),
                new \DateTimeImmutable($recruitmentEndDate)
            );
        } else {
            $recruitmentData['labels'] = [];
        }

        foreach ($list_of_sites as $siteID => $siteName) {
            $recruitmentData['datasets'][] = [
                "name" => $siteName,
                "data" => $this->_getSiteLineRecruitmentData(
                    $siteID,
                    $recruitmentData['labels'],
                    $conditions['cohortJoin'],
                    $conditions['participantStatusJoin'],
                    $conditions['cohortQuery'],
                    $conditions['projectQuery'],
                    $conditions['participantStatusQuery']
                ),
            ];
        }
        return new \LORIS\Http\Response\JsonResponse($recruitmentData);
    }

    /**
     * Helper to parse the GET parameters from the incoming request.
     *
     * @return array
     */
    private function _parseGetParameters()
    {
        $selectedProjects = empty($_GET['selectedProjects'])
        || $_GET['selectedProjects'] === 'null'
        || $_GET['selectedProjects'] === 'undefined'
        ? null : explode(",", $_GET['selectedProjects']);
        $selectedCohorts  = empty($_GET['selectedCohorts'])
        || $_GET['selectedCohorts'] === 'null'
        || $_GET['selectedCohorts'] === 'undefined'
        ? null : explode(",", $_GET['selectedCohorts']);
        $selectedSites    = empty($_GET['selectedSites'])
            || $_GET['selectedSites'] === 'null'
            || $_GET['selectedSites'] === 'undefined'
            ? null : explode(",", $_GET['selectedSites']);
        $selectedVisits   = empty($_GET['selectedVisits'])
            || $_GET['selectedVisits'] === 'null'
            || $_GET['selectedVisits'] === 'undefined'
            ? null : explode(",", $_GET['selectedVisits']);
        $selectedParticipantStatus = empty(
            $_GET['selectedParticipantStatus']
        )
                || $_GET['selectedParticipantStatus'] === 'null'
                || $_GET['selectedParticipantStatus'] === 'undefined' ? null
            : explode(
                ",",
                $_GET['selectedParticipantStatus']
            );

        return [
            'selectedProjects'          => $selectedProjects,
            'selectedCohorts'           => $selectedCohorts,
            'selectedSites'             => $selectedSites,
            'selectedVisits'            => $selectedVisits,
            'selectedParticipantStatus' => $selectedParticipantStatus,
        ];
    }

    /**
     * Helper to generate query conditions for for incoming requests.
     *
     * @param array $params       The parameters from the incoming request.
     * @param bool  $scansbymonth Whether or not the request is for scans by month.
     *
     * @return array
     */
    private function _buildQueryConditions(
        $params,
        $scansbymonth = false
    ) {
        $user = \NDB_Factory::singleton()->user();

        $projectQuery = '';
        $cohortQuery  = '';
        $cohortJoin   = '';
        $visitQuery   = '';
        $PSJoin       = '';
        $participantStatusQuery = '';

        if (!is_null($params['selectedProjects'])) {
            $projectString = "'" . implode("','", $params['selectedProjects']) . "'";
            $projectQuery  = " AND t.RegistrationProjectID IN ({$projectString}) ";
        }

        if (!is_null($params['selectedCohorts'])) {
            $cohortString = "'" . implode("','", $params['selectedCohorts']) . "'";
            $cohortQuery  = " AND s.CohortID IN ({$cohortString}) ";
            $cohortJoin   = "JOIN session s ON s.CandID=t.CandID";
        }
        if (!is_null($params['selectedSites'])) {
            // Set site query if selected
            $siteString = "'" . implode("','", $params['selectedSites']) . "'";
            $siteQuery  = " AND t.RegistrationCenterID IN ({$siteString}) ";
            if ($scansbymonth === true) {
                $siteQuery = " AND s.CenterID IN ({$siteString}) ";
            }
        } else {
            // If not selected, only take user sites
            $centerIDs  = $user->getCenterIDs();
            $centerList = "'" . implode("','", $centerIDs) . "'";
            $siteQuery  = " AND t.RegistrationCenterID IN ({$centerList}) ";
            if ($scansbymonth === true) {
                $siteQuery = " AND s.CenterID IN ({$centerList}) ";
            }
        }
        if (!is_null($params['selectedVisits'])) {
            // Set visit query if visits selected
            $visitString = "'" . implode("','", $params['selectedVisits']) . "'";
            $visitQuery  = " AND s.Visit_label IN ({$visitString}) ";
            // since they are the same, if visits are selected,
            // then the cohort string is overwritten
            $cohortJoin = "JOIN session s ON s.CandID=t.CandID";
        }
        if (!is_null($params['selectedParticipantStatus'])) {
            $PSJoin = 'LEFT JOIN participant_status ps ON t.CandID=ps.CandID';
            $participantStatusString = "'" . implode(
                "','",
                $params['selectedParticipantStatus']
            ) . "'";
            // Null participant status counts as Active because
            // sometimes users do not update the participant_status tab
            if (in_array('1', $params['selectedParticipantStatus'])) {
                $participantStatusQuery = " AND (
                    ps.participant_status IN ({$participantStatusString}) 
                    OR ps.participant_status IS NULL
                )";
            } else {
                $participantStatusQuery = " AND ps.participant_status
                IN ({$participantStatusString}) ";
            }
        }

        return [
            'projectQuery'           => $projectQuery,
            'cohortQuery'            => $cohortQuery,
            'cohortJoin'             => $cohortJoin,
            'visitQuery'             => $visitQuery,
            'siteQuery'              => $siteQuery,
            'participantStatusJoin'  => $PSJoin,
            'participantStatusQuery' => $participantStatusQuery,
        ];
    }

    /**
     * Helper to generate labels for every month between startDate and endDate.
     *
     * @param \DateTimeImmutable $startDate The start date for the labels.
     * @param \DateTimeImmutable $endDate   The end date for the labels.
     *
     * @return array
     */
    private function _createSiteLineChartLabels(
        \DateTimeImmutable $startDate,
        \DateTimeImmutable $endDate
    ) : array {
        $month = date_interval_create_from_date_string('1 month');

        // Since we're only concerned with months, act as if $startDate
        // is always the first of the month so that the last month doesn't
        // get truncated.
        $betweenDate = new \DateTimeImmutable($startDate->format('Y-m-01'));

        $labels = [];

        while ($betweenDate <= $endDate) {
            $labels[]    = $betweenDate->format('n-Y');
            $betweenDate = $betweenDate->add($month);
        }
        return $labels;
    }

    /**
     * Helper to generate the data for the site recruitment line for $siteID.
     *
     * @param int    $siteID                 The centerID to get data for.
     * @param array  $labels                 The list of labels on the chart
     *                                       to fill the data for.
     * @param String $cohortJoin             The join statement for cohort if needed
     * @param String $PSJoin                 The join statement for
     *                                       participantStatusJoin
     *                                       if needed
     * @param String $cohortQuery            The where statement for cohort if needed
     * @param String $projectQuery           The where statement
     *                                       for project if needed
     * @param String $participantStatusQuery The where statement for
     *                                       participantStatus if needed
     *
     * @return array
     */
    private function _getSiteLineRecruitmentData(
        $siteID,
        $labels,
        $cohortJoin,
        $PSJoin,
        $cohortQuery,
        $projectQuery,
        $participantStatusQuery
    ) {
        $DB   = \NDB_Factory::singleton()->database();
        $data = [];

        foreach ($labels as $label) {
            $month = (strlen($label) == 6)
                ? substr($label, 0, 1) : substr($label, 0, 2);
            $year  = substr($label, -4, 4);

            $data[] = $DB->pselectOne(
                "SELECT COUNT(t.CandID)
                FROM candidate t
                {$cohortJoin}
                {$PSJoin}
                WHERE t.RegistrationCenterID=:Site
                AND MONTH(t.Date_registered)=:Month
                AND YEAR(t.Date_registered)=:Year
                AND t.Entity_type='Human'
                {$cohortQuery}
                {$projectQuery}
                {$participantStatusQuery}",
                [
                    'Site'  => $siteID,
                    'Month' => $month,
                    'Year'  => $year,
                ]
            );
        }
        return $data;
    }
}
